<!DOCTYPE html>
<html>
    <head>
        <meta charset = "utf-8">
        <title>sid</title>
        <link rel="stylesheet" href = "style-solutions.css">
        <link href="https://fonts.googleapis.com/css?family=Courier+Prime&display=swap" rel="stylesheet">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <script src = "js/home.js"></script>
    </head>
    
    <body>
        <div id = "transition">
            <div class = "header">
                <h1>The Bucket List</h1>
                <h2>USACO December 2018 Bronze</h2>

                <hr>
            </div>
            
            <div class = "statement">
                <p>For this problem, we can consider time to be a one-dimensional property associated with a number line, where each unit represents a unit of time. In the context of the problem, we can draw out a number line and assign line segments that represent times that a cow is being milked. To determine the range in which calculation is necessary, we can take in the input and find the starting point (the minimum starting value out of all of the cows) and the ending point (the maximum ending value out of all of the cows). From there, we can traverse through every unit of time, checking what cows are being milked and how many buckets of milk we need. Note that since <i>b_i</i> is in the range <i>1 &#8804; b_i &#8804; 1000</i>, we complete search in at most 1000 iterations; in other words, our problem will run with ample time to spare.
                <br><br>
                I created a cow object with three properties: startTime, endTime, and bucketsRequired. With this object, I was able to easily manage the data. For each unit of time traversed, I checked what cows were being milked via a conditional "&amp;&amp;" statement. I added the amount of buckets required for each cow to the variable <i>cb</i>. If a cow was finished milking, I subtracted that cow's amount of required milk from <i>cb</i>. If <i>cb</i> ever exceeded the total required buckets, the variable <i>totalBuckets</i> would be updated to accomodate for the change. In retrospect, simply implementing the Math.max function would have been smarter, but my method was just 2 extra lines.
                <br><br>
                Problem Tags: Complete Search, One-Dimensional Line, Data Storage via an Object
                </p>
            </div>
            
            <div class = "solution">
            <pre>
// <i>@author Sid Banerjee, 2020</i>         
            
import java.io.*;
import java.util.*;

public class blist {
    public static void main(String[] args) throws IOException {
        Scanner in = new Scanner(new File("blist.in"));
        PrintWriter pw = new PrintWriter(new File("blist.out"));

        // input here
        int n = in.nextInt(); in.nextLine();
        cow[] cows = new cow[n];
        for(int i = 0; i < n; i++){
            cows[i] = new cow(in.nextInt(), in.nextInt(), in.nextInt());
            if(in.hasNextLine()){
                in.nextLine();
            }
        }

        int minTime = Integer.MAX_VALUE, maxTime = Integer.MIN_VALUE;
        for(cow c : cows){
            minTime = Math.min(minTime, c.getStartTime());
            maxTime = Math.max(maxTime, c.getEndTime());
        }

        // algorithm here
        int totalBuckets = 0;
        for(int i = minTime; i <= maxTime; i++){
            int cb = 0;
            for(cow c : cows){ // check if any cow is being milked at the current time
                if(i >= c.getStartTime() && i <= c.getEndTime()){
                    cb += c.getBucketsRequired();
                }

                // is a cow finishing milking?
                if(i == c.getEndTime()+1){
                    cb -= c.getBucketsRequired();
                }
                if(cb > totalBuckets){
                    totalBuckets = cb;
                }
            }
        }

        pw.println(totalBuckets);
        pw.close();
    }

    static class cow {

        int startTime, endTime, bucketsRequired;

        public cow(int startTime, int endTime, int bucketsRequired){
            this.startTime = startTime;
            this.endTime = endTime;
            this.bucketsRequired = bucketsRequired;
        }

        public int getStartTime() {
            return startTime;
        }

        public int getEndTime() {
            return endTime;
        }

        public int getBucketsRequired() {
            return bucketsRequired;
        }
    }
}

            </pre>
            </div>
        </div>
    </body>
</html>